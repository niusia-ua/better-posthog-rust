//! Identity strategy configuration for PostHog user identification.

use tauri::Manager as _;

const IDENTITY_FILE_NAME: &str = ".posthog-id";

/// Strategy for determining the user's distinct ID.
///
/// The distinct ID is resolved once during plugin initialization and cached for the lifetime of the application.
#[derive(Default)]
pub enum IdentityStrategy<R: tauri::Runtime> {
  /// Automatically generates and persists a UUID v4 to the app data directory.
  ///
  /// On first run, creates a `.posthog.id` file containing a new UUID.
  /// On subsequent runs, reads the existing UUID from the file.
  ///
  /// If file I/O fails, falls back to [`Anonymous`](IdentityStrategy::Anonymous) mode.
  #[default]
  Autogenerated,

  /// Uses a developer-provided closure to resolve the distinct ID.
  ///
  /// The closure receives the `AppHandle` and should return:
  /// - `Some(id)` to use a specific distinct ID
  /// - `None` to fall back to anonymous mode
  #[allow(clippy::type_complexity)]
  Custom(Box<dyn Fn(&tauri::AppHandle<R>) -> Option<String> + Send + Sync>),

  /// Explicitly opts out of persistent identification.
  ///
  /// Each event will use a transient UUID v7 generated at capture time.
  /// The session ID is still attached to all events for session continuity.
  Anonymous,
}

impl<R: tauri::Runtime> IdentityStrategy<R> {
  /// Resolves the distinct ID based on the configured strategy.
  ///
  /// Returns `Some(id)` for identified users, `None` for anonymous mode.
  pub(crate) fn resolve(&self, app_handle: &tauri::AppHandle<R>) -> Option<String> {
    match self {
      Self::Autogenerated => resolve_autogenerated(app_handle),
      Self::Custom(resolve) => resolve(app_handle),
      Self::Anonymous => None,
    }
  }
}

/// Resolves the autogenerated identity by reading or creating the identity file.
fn resolve_autogenerated<R: tauri::Runtime>(app_handle: &tauri::AppHandle<R>) -> Option<String> {
  let Some(identity_path) = app_handle
    .path()
    .app_data_dir()
    .ok()
    .map(|dir| dir.join(IDENTITY_FILE_NAME))
  else {
    log::warn!("Failed to resolve app data directory, falling back to anonymous mode");
    return None;
  };

  if let Ok(id) = std::fs::read_to_string(&identity_path) {
    let id = id.trim();
    if !id.is_empty() {
      return Some(id.to_string());
    }
  }

  let id = uuid::Uuid::new_v4().to_string();

  if let Some(parent) = identity_path.parent()
    && let Err(e) = std::fs::create_dir_all(parent)
  {
    log::warn!("Failed to create app data directory: {e}, falling back to anonymous mode");
    return None;
  }

  if let Err(e) = std::fs::write(&identity_path, &id) {
    log::warn!("Failed to write identity file: {e}, falling back to anonymous mode");
    return None;
  }

  Some(id)
}
